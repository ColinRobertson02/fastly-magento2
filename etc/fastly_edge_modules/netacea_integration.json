{
  "description": "Set of VCLs required to integrate Netacea services. Please note for full functionality Fastly support needs to enable proper handling of POST requests. Do not enable unless this has been done.",
  "id": "netacea_integration",
  "name": "Netacea Bot Detection integration",
  "properties": [
    {
      "description": "API Key",
      "label": "Netacea API Key",
      "name": "netacea_api_key",
      "required": true,
      "type": "string"
    },
    {
      "description": "Secret",
      "label": "Netacea Secret",
      "name": "netacea_secret",
      "required": true,
      "type": "string"
    },
    {
      "description": "Up to 5 comma separated URL paths that API Protector will ignore. Please start URL paths with a forward slash. Example: /test, /allowed/, /path/to/something",
      "label": "Netacea ignore list - URL Paths",
      "name": "netacea_ignore_list",
      "required": false,
      "type": "string"
    }
  ],
  "vcl": [
    {
      "priority": 45,
      "template": "# Change the shielding condition to account for restarts due to bot detection\nset var.fastly_req_do_shield = (req.restarts <= 1);\n# Reenable clustering. It gets turned off on restarts\nset req.http.Fastly-Force-Shield = \"1\";\n# Ignore list check\ndeclare local var.ignored BOOL;\ndeclare local var.netacea_request_path STRING;\ndeclare local var.netacea_ignore_list STRING;\ndeclare local var.netacea_first_ignored_path STRING;\ndeclare local var.netacea_second_ignored_path STRING;\ndeclare local var.netacea_third_ignored_path STRING;\ndeclare local var.netacea_fourth_ignored_path STRING;\ndeclare local var.netacea_fifth_ignored_path STRING;\n\nset var.netacea_ignore_list = table.lookup(Netacea_Config, \"ignore_list\");\nset var.ignored = false;\n\n# Extract and set ignored URL paths\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_first_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_second_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_third_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_fourth_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_fifth_ignored_path = regsub(re.group.1, \" \", \"\");\n}\n\n# Check request's URL path\nif (\n  std.prefixof(req.url.path, var.netacea_first_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_second_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_third_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_fourth_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_fifth_ignored_path)\n) {\n  set var.ignored = true;\n}\n\nif(var.ignored == false) {\n  # Invoke Netacea Bot Detection checking\n  call netacea_recv;\n}",
      "type": "recv"
    },
    {
      "priority": 45,
      "template": "# Ignore list check\ndeclare local var.ignored BOOL;\ndeclare local var.netacea_request_path STRING;\ndeclare local var.netacea_ignore_list STRING;\ndeclare local var.netacea_first_ignored_path STRING;\ndeclare local var.netacea_second_ignored_path STRING;\ndeclare local var.netacea_third_ignored_path STRING;\ndeclare local var.netacea_fourth_ignored_path STRING;\ndeclare local var.netacea_fifth_ignored_path STRING;\n\nset var.netacea_ignore_list = table.lookup(Netacea_Config, \"ignore_list\");\nset var.ignored = false;\n\n# Extract and set ignored URL paths\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_first_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_second_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_third_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_fourth_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_fifth_ignored_path = regsub(re.group.1, \" \", \"\");\n}\n\n# Check request's URL path\nif (\n  std.prefixof(req.url.path, var.netacea_first_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_second_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_third_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_fourth_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_fifth_ignored_path)\n) {\n  set var.ignored = true;\n}\n\nif(var.ignored == false) {\n  # Invoke Netacea Bot Detection checking\n  call netacea_deliver;\n}",
      "type": "deliver"
    },
    {
      "priority": 45,
      "template": "backend F_MitSvc {
        .between_bytes_timeout = 0.5s;
        .connect_timeout = 1s;
        .dynamic = true;
        .first_byte_timeout = 1s;
        .host = \"mitigations.netacea.net\";
        .max_connections = 200;
        .port = \"443\";
        .share_key = \"NETACEAmitigations\";
        .ssl = true;
        .ssl_cert_hostname = \"mitigations.netacea.net\";
        .ssl_check_cert = always;
        .ssl_sni_hostname = \"mitigations.netacea.net\";
        .probe = {
            .dummy = true;
            .initial = 5;
            .request = \"HEAD / HTTP/1.1\"  \"Host: mitigations.netacea.net\" \"Connection: close\";
            .threshold = 1;
            .timeout = 2s;
            .window = 5;
          }
    }
    
    # BYPASS - disable Netacea integration
    # INGEST - set cookie to track visitors but do not mitigate
    # MITIGATE - enforce Netacea blocklist
    table Netacea_Config {
      \"integration_type\": \"MITIGATE\",
      \"api_key\": \"{{netacea_api_key}}\",
      \"secret_key\": \"{{netacea_secret}}\",
      \"ignore_list\": \"{{netacea_ignore_list}}\"
    }
    
    sub netacea_recv {
      declare local var.netacea_mitSvc_authenticate BOOL;
      declare local var.netacea_mitSvc_apiKey STRING;
      declare local var.netacea_mitSvc_secret STRING;
      declare local var.netacea_integration_type STRING;
    
      set var.netacea_mitSvc_apiKey = table.lookup(Netacea_Config, \"api_key\");
      set var.netacea_mitSvc_secret = table.lookup(Netacea_Config, \"secret_key\");
      set var.netacea_integration_type = table.lookup(Netacea_Config, \"integration_type\");
    
      # Unset headers Netacea Set
      unset req.http.netacea_processed;
      if (req.restarts == 0 && fastly.ff.visits_this_service == 0) {
        set req.http.netacea_best_mitigation_code = \"000\";
        set req.http.netacea_match = \"0\";
        set req.http.netacea_mitigate = \"0\";
        set req.http.netacea_captcha = \"0\";
        set req.http.X-Netacea-Client-IP = client.ip;
    
        unset req.http.mit_status;
        unset req.http.netacea_bctype_string;
        unset req.http.netacea_best_mitigation;
        unset req.http.netacea_cookies;
        unset req.http.netacea_mitata_captcha_cookie_expiry;
        unset req.http.netacea_mitata_captcha_cookie_value;
        unset req.http.netacea_mitata_must_reauthenticate;
        unset req.http.netacea_require_revalidation;
        unset req.http.netacea_set_cookies;
        unset req.http.X-Netacea-Api-Key;
        unset req.http.X-Netacea-Captcha-Status;
        unset req.http.X-Netacea-UserId;
        if (var.netacea_integration_type != \"BYPASS\") {
          set var.netacea_mitSvc_authenticate = true;
    
          # Parse & validate _mitata cookie. Unsets cookie if invalid.
          call process_netacea_mitata_cookie;
    
          # Parse & validate _mitatacaptcha cookie. Unset cookie if invalid.
          # Relies on req.http.X-Netacea-UserId being set by process_netacea_mitata_cookie
          call process_netacea_mitatacaptcha_cookie;
        }
      } else {
        if (req.http.netacea_best_mitigation == \"block\") {
          error 403;
        }
      }
    
      if (req.http.Cookie:_mitata && !req.http.netacea_mitata_must_reauthenticate) {
        # Cookie is valid and not expired, no need for additional authentication
        set var.netacea_mitSvc_authenticate = false;
      }
    
      # set User ID, integration type, and integration version so they can be logged
      set req.http.mitigation_user_id = req.http.X-Netacea-UserId;
      set req.http.integration_type = \"fastly/magento\";
      set req.http.integration_version = \"4.2.0\";
    
      if (var.netacea_mitSvc_authenticate) {
        set req.http.netacea_set_cookies = \"1\";
      }
    
      if (var.netacea_integration_type == \"MITIGATE\" && var.netacea_mitSvc_authenticate) {
        set req.backend = F_MitSvc;
        if (req.backend.healthy) {
          unset req.http.netacea_match;
          unset req.http.netacea_mitigate;
          unset req.http.netacea_captcha;
          unset req.http.Cookie:_mitata;
    
          set req.http.netacea_origin_method = req.method;
          set req.http.netacea_processed = \"1\";
          set req.http.netacea_origin_host = req.http.host;
          set req.http.netacea_origin_url = req.url;
          if (req.url != \"/AtaVerifyCaptcha\") {
            set req.method = \"GET\";
            set req.url = \"/\";
          }
          set req.http.X-Netacea-Api-Key = var.netacea_mitSvc_apiKey;
          return(pass);
        }
      }
    }
    
    sub netacea_deliver {
      call netacea_calculate_best_mitigation;
    
      if (req.http.netacea_processed == \"1\") {
        set req.http.mit_status = resp.status;
        if (resp.status != 200) {
          // Unset these because we're not mitigating anything.
          set req.http.netacea_best_mitigation = \"\";
          set req.http.netacea_bctype_string = \"\";
          // If the AtaVerifyCaptcha is not returning a 200 assume it was not successful and do not set cookies
          if(req.url == \"/AtaVerifyCaptcha\") {
            set req.http.netacea_set_cookies = \"0\";
          }
        }
        set req.http.host = req.http.netacea_origin_host;
        set req.url = req.http.netacea_origin_url;
        set req.method = req.http.netacea_origin_method;
        //set req.http.netacea_cookies = resp.http.Set-Cookie;
        set req.http.netacea_mitata_captcha_cookie_value = resp.http.x-netacea-mitatacaptcha-value;
        set req.http.netacea_mitata_captcha_cookie_expiry = resp.http.x-netacea-mitatacaptcha-expiry;
    
        unset req.http.netacea_origin_url;
        unset req.http.netacea_origin_host;
        unset req.http.netacea_origin_method;
        unset req.http.X-Netacea-Api-Key;
        call set_netacea_cookies;
        if (req.http.netacea_best_mitigation != \"captcha\") {
          restart;
        }
        set resp.status = 403;
        set resp.http.content-type = \"text/html; charset=UTF-8\";
        return(deliver);
      }
      call set_netacea_cookies;
    }
    
    sub set_netacea_cookies {
      if (req.http.netacea_set_cookies == \"1\") {
        # Remove any existing netacea cookies being set
        declare local var.ignored BOOL;
        set var.ignored = setcookie.delete_by_name(resp, \"_mitata\");
        set var.ignored = setcookie.delete_by_name(resp, \"_mitatacaptcha\");
    
        call set_mitata_cookie;
    
        if (req.http.netacea_mitata_captcha_cookie_value && req.http.netacea_mitata_captcha_cookie_expiry) {
          add resp.http.Set-Cookie= \"_mitatacaptcha=\" + req.http.netacea_mitata_captcha_cookie_value + \"; Max-Age=\" + req.http.netacea_mitata_captcha_cookie_expiry + \"; Path=/;\";
        }
      }
    }
    
    table Netacea_Match_Dict {
      \"0\": \"\",
      \"1\": \"ua\",
      \"2\": \"ip\",
      \"3\": \"visitor\",
      \"4\": \"datacenter\",
      \"5\": \"sev\",
      \"6\": \"organisation\", 
      \"7\": \"asn\",
      \"8\": \"country\",
      \"9\": \"combination\"
    }
    
    table Netacea_Mitigate_Dict {
      \"0\": \"\",
      \"1\": \"blocked\",
      \"2\": \"allow\",
      \"3\": \"hardblocked\"
    }
    
    table Netacea_Best_Mitigations_Dict {
      \"0\": \"\",
      \"1\": \"block\",
      \"2\": \"allow\",
      \"3\": \"block\"
    }
    
    table Netacea_Best_Mitigations_Captcha_Dict {
      \"1\": \"captcha\",
      \"2\": \"\",
      \"3\": \"captcha\",
      \"4\": \"\",
      \"5\": \"captcha\"
    }
    
    table Netacea_Captcha_Dict {
      \"0\": \"\",
      \"1\": \"captcha_serve\",
      \"2\": \"captcha_pass\",
      \"3\": \"captcha_fail\",
      \"4\": \"captcha_cookiepass\",
      \"5\": \"captcha_cookiefail\",
    }
    
    sub netacea_calculate_best_mitigation {
      if (!req.http.netacea_bctype_string) {
        declare local var.netacea_match STRING;
        declare local var.netacea_mitigate STRING;
        declare local var.netacea_captcha STRING;
        declare local var.netacea_match_string STRING;
        declare local var.netacea_mitigate_string STRING;
        declare local var.netacea_captcha_string STRING;
        declare local var.netacea_captcha_mitigate_string STRING;
    
        declare local var.netacea_best_mitigation STRING;
        declare local var.netacea_bctype_string STRING;
    
        if (resp.http.x-netacea-match) { # If netacea mitigation service returns a match, use this
          set var.netacea_match = resp.http.x-netacea-match;
        } elseif (req.http.netacea_match) { # If cookie has a match, use this
          set var.netacea_match = req.http.netacea_match;
        } else {
          set var.netacea_match = \"0\";
        }
    
        if (resp.http.x-netacea-mitigate) { # If netacea mitigation service returns a mitigate, use this
          set var.netacea_mitigate = resp.http.x-netacea-mitigate;
        } elseif (req.http.netacea_mitigate) { # If cookie has a mitigate, use this
          set var.netacea_mitigate = req.http.netacea_mitigate;
        } else {
          set var.netacea_mitigate = \"0\";
        }
    
        if (resp.http.x-netacea-captcha) { # If netacea mitigation service returns a captcha, use this
          set var.netacea_captcha = resp.http.x-netacea-captcha;
        } elseif (req.http.netacea_captcha) { # If cookie has a captcha, use this
          set var.netacea_captcha = req.http.netacea_captcha;
        } else {
          set var.netacea_captcha = \"0\";
        }
    
    
        # IP, UA, Visitor, Datacentre etc
        if (var.netacea_match) {
          set var.netacea_match_string = table.lookup(Netacea_Match_Dict, var.netacea_match, \"unknown\");
    
          if (var.netacea_match_string != \"\") {
            set var.netacea_bctype_string = var.netacea_match_string + \"_\";
          }
        }
    
        # BLOCK, TRUST, HARDBLOCK etc
        if (var.netacea_mitigate) {
          set var.netacea_mitigate_string = table.lookup(Netacea_Mitigate_Dict, var.netacea_mitigate, \"unknown\");
    
          if (var.netacea_mitigate_string != \"\") {
            set var.netacea_bctype_string = var.netacea_bctype_string + var.netacea_mitigate_string;
          }
    
          set var.netacea_best_mitigation = table.lookup(Netacea_Best_Mitigations_Dict, var.netacea_mitigate, \"no-best-mitigation\");
          if (var.netacea_best_mitigation == \"no-best-mitigation\") {
            set var.netacea_best_mitigation = \"\";
          }
        }
    
        if (var.netacea_captcha) {
          # 2 and 3 can only be set on /AtaVerifyCaptcha requests
          # If it's not 2 or 3 then set them to the cookie variant
          if (req.url != \"/AtaVerifyCaptcha\") {
            if (var.netacea_captcha == \"2\") {
              set var.netacea_captcha = \"4\";
            } elseif (var.netacea_captcha == \"3\") {
              set var.netacea_captcha = \"5\";
            }
          }
          set var.netacea_captcha_string = table.lookup(Netacea_Captcha_Dict, var.netacea_captcha, \"unknown\");
    
          if (var.netacea_captcha_string != \"\") {
            set var.netacea_bctype_string = var.netacea_bctype_string + \",\" + var.netacea_captcha_string;
          }
          set var.netacea_captcha_mitigate_string = table.lookup(Netacea_Best_Mitigations_Captcha_Dict, var.netacea_captcha, \"no-best-captcha-mitigation\");
          if (var.netacea_captcha_mitigate_string != \"no-best-captcha-mitigation\") {
            set var.netacea_best_mitigation = var.netacea_captcha_mitigate_string;
          }
        }
    
        set req.http.netacea_bctype_string = var.netacea_bctype_string;
        set req.http.netacea_best_mitigation = var.netacea_best_mitigation;
        set req.http.netacea_best_mitigation_code = var.netacea_match + var.netacea_mitigate + var.netacea_captcha;
    
        # Require re-validation if hard blocked
        if (var.netacea_mitigate == \"3\") {
          set req.http.netacea_require_revalidation = \"1\";
        }
    
        # Require re-validation if not passed captcha
        if (var.netacea_mitigate == \"1\" && var.netacea_captcha != \"2\" && var.netacea_captcha != \"4\") {
          set req.http.netacea_require_revalidation = \"1\";
        }
    
        # Unset x-netacea headers
        # unset resp.http.x-netacea-match;
        # unset resp.http.x-netacea-mitigate;
        # unset resp.http.x-netacea-captcha;
    
      }
    }
    
    sub set_mitata_cookie {
        declare local var.netacea_mitSvc_secret STRING;
        set var.netacea_mitSvc_secret = table.lookup(Netacea_Config, \"secret_key\");
    
        declare local var.netacea_integration_type STRING;
    
        set var.netacea_integration_type = table.lookup(Netacea_Config, \"integration_type\");
    
        # Set User ID for new user
        if (!req.http.X-Netacea-UserId) {
          # \"c\" prefix indicates the ID was generated in a Netacea customer integration
          set req.http.X-Netacea-UserId = \"c\" + randomstr(15, \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");
        }
    
        # Declare vars for _mitata cookie parts
        declare local var.netacea_mitata_cookie_full_value STRING;
        declare local var.netacea_ataCookie_stringValue STRING;
        declare local var.netacea_ataCookie_HMAC STRING;
        declare local var.netacea_mitSvc_exp STRING;
        declare local var.netacea_mitSvc_sig STRING;
        declare local var.netacea_mitSvc_userId STRING;
        declare local var.netacea_mitigation_code STRING;
        declare local var.netacea_client_ip_time_hash STRING;
        set var.netacea_mitigation_code = req.http.netacea_best_mitigation_code;
        set var.netacea_mitSvc_userId = req.http.X-Netacea-UserId;
    
        # Set cookie expiry
        if (req.http.netacea_require_revalidation == \"1\") {
          // Serving captcha. Set time in past to force re-validation until passed.
          set var.netacea_mitSvc_exp = time.units(\"s\", time.sub(now, 1m));
        } else {
          set var.netacea_mitSvc_exp = time.units(\"s\", time.add(now, 1m));
        }
    
        # Create signature
        set var.netacea_client_ip_time_hash = digest.hmac_sha256(var.netacea_mitSvc_secret, req.http.X-Netacea-Client-IP + var.netacea_mitSvc_exp);
        if (var.netacea_client_ip_time_hash ~ \"0x(.*)\") {
          set var.netacea_client_ip_time_hash = re.group.1;
        }
        set var.netacea_ataCookie_stringValue = var.netacea_mitSvc_exp + \"_/@#/\" + var.netacea_mitSvc_userId + \"_/@#/\" + digest.base64(var.netacea_client_ip_time_hash) + \"_/@#/\" + var.netacea_mitigation_code;
        set var.netacea_ataCookie_HMAC = digest.hmac_sha256(var.netacea_mitSvc_secret, var.netacea_ataCookie_stringValue);
        if (var.netacea_ataCookie_HMAC ~ \"0x(.*)\") {
          set var.netacea_ataCookie_HMAC = re.group.1;
        }
    
        # Set signed cookie
        set var.netacea_mitSvc_sig = digest.base64(var.netacea_ataCookie_HMAC);
        set var.netacea_mitata_cookie_full_value = var.netacea_mitSvc_sig + \"_/@#/\" + var.netacea_ataCookie_stringValue;
        add resp.http.Set-Cookie= \"_mitata=\" + var.netacea_mitata_cookie_full_value + \"; Max-Age=\" + time.units(\"s\", 1d) + \"; Path=/;\";
    
        # set user ID so that it can be logged. Could be dome somewhere else?
        set req.http.mitigation_user_id = var.netacea_mitSvc_userId;
    }
    
    # Read _mitata cookie to get User ID and any existing mitigation
    # Unsets _mitata if signature is not valid
    # Uses:
    #   req.http.Cookie:_mitata
    # May set:
    #   req.http.X-Netacea-UserId
    #   req.http.netacea_match
    #   req.http.netacea_mitigate
    #   req.http.netacea_captcha
    #   req.http.netacea_mitata_must_reauthenticate
    sub process_netacea_mitata_cookie {
      declare local var.netacea_mitSvc_secret STRING;
      set var.netacea_mitSvc_secret = table.lookup(Netacea_Config, \"secret_key\");
    
      declare local var.netacea_cookie_sig STRING;
      declare local var.netacea_cookie_payload STRING;
      declare local var.netacea_cookie_expiry STRING;
      declare local var.netacea_client_ip_time_hash STRING;
      declare local var.netacea_real_client_ip_time_hash STRING;
      declare local var.netacea_cookie_HMAC STRING;
      declare local var.netacea_cookie_real_value STRING;
    
      if (req.http.Cookie:_mitata) {
        if (req.http.Cookie:_mitata ~ \"^(.*)_\\/@#\\/((\\d+)_\\/@#\\/(.+)_\\/@#\\/(.+)_\\/@#\\/((\\d)(\\d)(\\d)))$\") {
          set var.netacea_cookie_sig = re.group.1;
          set var.netacea_cookie_payload = re.group.2;
          set var.netacea_cookie_expiry = re.group.3;
          set req.http.X-Netacea-UserId = re.group.4;
          set var.netacea_client_ip_time_hash = re.group.5;
          set req.http.netacea_match = re.group.7;
          set req.http.netacea_mitigate = re.group.8;
          set req.http.netacea_captcha = re.group.9;
          set var.netacea_cookie_real_value = var.netacea_cookie_expiry + \"_/@#/\" +  req.http.X-Netacea-UserId + \"_/@#/\" + var.netacea_client_ip_time_hash + \"_/@#/\" + req.http.netacea_match + req.http.netacea_mitigate + req.http.netacea_captcha;
    
          # Calculate HMACs
          set var.netacea_cookie_HMAC = digest.hmac_sha256(var.netacea_mitSvc_secret, var.netacea_cookie_real_value);
          if (var.netacea_cookie_HMAC ~ \"0x(.*)\") {
            set var.netacea_cookie_HMAC = re.group.1;
          }
    
          set var.netacea_real_client_ip_time_hash = digest.hmac_sha256(var.netacea_mitSvc_secret, req.http.X-Netacea-Client-IP + var.netacea_cookie_expiry);
          if (var.netacea_real_client_ip_time_hash ~ \"0x(.*)\") {
            set var.netacea_real_client_ip_time_hash = re.group.1;
          }
    
          if (var.netacea_cookie_sig != digest.base64(var.netacea_cookie_HMAC)) {
            # Delete cookie with invalid HMAC
            unset req.http.Cookie:_mitata;
            # Unset these headers as we can no longer trust them:
            unset req.http.X-Netacea-UserId;
            unset req.http.netacea_match;
            unset req.http.netacea_mitigate;
            unset req.http.netacea_captcha;
          } else {
            if (time.is_after(now, std.time(var.netacea_cookie_expiry, now)) || digest.base64(var.netacea_real_client_ip_time_hash) != var.netacea_client_ip_time_hash ) {
              # Cookie is expired or IP has changed
              set req.http.netacea_mitata_must_reauthenticate = \"1\";
            }
          }
        } else {
          # Delete cookie which does not match regex
          unset req.http.Cookie:_mitata;
        }
      }
    
      # Cannot have _mitatacaptcha without _mitata
      if (!req.http.Cookie:_mitata) {
        unset req.http.Cookie:_mitatacaptcha;
      }
    }
    
    # Read _mitatacaptcha cookie to assess whether the user has passed captcha
    # Unsets _mitatacaptcha if signature is not valid
    # Uses:
    #   req.http.Cookie:_mitatacaptcha
    #   req.http.X-Netacea-UserId
    # May set:
    #   req.http.X-Netacea-Captcha-Status: either \"captcha_pass\" or \"captcha_fail\"
    sub process_netacea_mitatacaptcha_cookie {
      declare local var.netacea_mitSvc_secret STRING;
      set var.netacea_mitSvc_secret = table.lookup(Netacea_Config, \"secret_key\");
    
      declare local var.netacea_cookie_sig STRING;
      declare local var.netacea_cookie_payload STRING;
      declare local var.netacea_cookie_HMAC STRING;
      declare local var.netacea_cookie_expiry STRING;
      declare local var.netacea_cookie_captcha_status STRING;
    
      if (req.http.Cookie:_mitatacaptcha) {
        if (req.http.Cookie:_mitatacaptcha ~ \"^(.*)_\\/@#\\/(\\d)_\\/@#\\/(\\d+)$\") {
          set var.netacea_cookie_sig = re.group.1;
          set var.netacea_cookie_captcha_status = re.group.2;
          set var.netacea_cookie_expiry = re.group.3;
    
          # Include User ID in payload for hash calculation.
          set var.netacea_cookie_payload = var.netacea_cookie_captcha_status + \"_/@#/\" + var.netacea_cookie_expiry + \"_/@#/\" + req.http.X-Netacea-UserId;
    
          # Calculate HMAC
          set var.netacea_cookie_HMAC = digest.hmac_sha256(var.netacea_mitSvc_secret, var.netacea_cookie_payload);
          if (var.netacea_cookie_HMAC ~ \"0x(.*)\") {
            set var.netacea_cookie_HMAC = re.group.1;
          }
    
          # Delete cookie with invalid HMAC
          if (var.netacea_cookie_sig != digest.base64(var.netacea_cookie_HMAC)) {
            unset req.http.Cookie:_mitatacaptcha;
          }
    
          # Delete expired cookie
          if (time.is_after(now, std.time(var.netacea_cookie_expiry, now))) {
            unset req.http.Cookie:_mitatacaptcha;
          }
    
          if (req.http.Cookie:_mitatacaptcha) {
            if (var.netacea_cookie_captcha_status == \"1\") {
              set req.http.X-Netacea-Captcha-Status = \"captcha_pass\";
            } else {
              set req.http.X-Netacea-Captcha-Status = \"captcha_fail\";
            }
          }
        } else {
          # Delete cookie which does not match regex
          unset req.http.Cookie:_mitatacaptcha;
        }
      }
    }",
      "type": "init"
    }
  ],
  "version": 3
}